#!/usr/bin/env roseus

(ros::load-ros-manifest "roseus")
(ros::load-ros-manifest "move_base_msgs")

(ros::load-ros-manifest "moveit_msgs")
(ros::load-ros-manifest "jsk_interactive")
(ros::load-ros-manifest "jsk_interactive_marker")
(ros::load-ros-manifest "jsk_rviz_plugins")
(ros::load-ros-manifest "jsk_pcl_ros")

(ros::roseus "ik-controller")

(require "models/arrow-object.l")
(require "package://roseus/euslisp/actionlib.l")
(require "package://pr2eus/pr2-interface.l")
(require "package://jsk_ik_server/euslisp/fullbody-ik-client.l")

;;;;;;;; setup ;;;;;;;;;;;
(defclass touch-it-client
  :super ros::simple-action-client
  :slots (feedback))
(defmethod touch-it-client
  (:action-feedback-cb
   (msg)
   (ros::ros-debug "[~A] feedback-cb ~A" ros::name-space msg)
   (setq feedback msg))
  (:feedback () feedback)
  (:simple-state () ros::simple-state)
  )

(defclass im-controller
  :slots
  (*robot*
   *lhand-frame*
   *rhand-frame*
   *fullbody-ik-client*
   *base-target-coords*
   *movingp*
   *have-leg*
   *frame-id*
   *ik-update-times*
   *target-update-times*
   )
  )

(defvar *touch-it-interface*
  (setq *c* (instance touch-it-client :init
		      "/touchit/act/exec"
		      move_base_msgs::MoveBaseAction)))
(defvar *touch-it-interface-ocs*
  (setq *c* (instance ros::simple-action-client :init
		      "/touchit/act/exec_ocs"
		      move_base_msgs::MoveBaseAction)))
(defvar *touchit-reached* 4)
(defvar *touchit-touched* 3)
(defvar *touchit-cancelled* 6)

(defvar *touchit-target-larm* 0)
(defvar *touchit-target-larm-torso* 1)
(defvar *touchit-target-larm-fullbody* 2)
(defvar *touchit-target-rarm* 3)
(defvar *touchit-target-rarm-torso* 4)
(defvar *touchit-target-rarm-fullbody* 5)

(defvar *touch-it-server-detected* nil)
(defvar *one-click-grasp-arm* :larm)

(defmethod im-controller
  (:call-touch-it-server
   (command
    &key
    (ik-type
     (cond
      ((eq *move-limb* :rarm)
       (cond
	(*use-fullbody* *touchit-target-rarm-fullbody*)
	(*use-torso* *touchit-target-rarm-torso*)
	(t *touchit-target-rarm*)))
      ((eq *move-limb* :larm)
       (cond
	(*use-fullbody* *touchit-target-larm-fullbody*)
	(*use-torso* *touchit-target-larm-torso*)
	(t *touchit-target-larm*)))))
    (frame_id (format nil "/~A" *robot-origin*))
    (target-coords *target-coords*)
    (target-coords-from-pelvis
     (send (send *robot* :copy-worldcoords)
	   :transformation target-coords))
    (touch-it-interface
     (case command
       (:prev *touch-it-interface-ocs*)
       (t *touch-it-interface*)))
    (axis
     (case *rotation-axis*
       (:z 0)
       (:x 1)
       (:y 2)
       (nil 3)
       (t 4)))
    res)
   (let (feedback-value feedback-value2)
     (case command
       (:cancel (send touch-it-interface :cancel-all-goals))
       (t
	(let* ((c target-coords-from-pelvis)
	       (p (scale 1e-3 (send c :worldpos)))
	       (q (matrix2quaternion (send c :worldrot)))
	       goal)
	  ;; set request
	  (warning-message 2 "[touch_it_client] start waiting for server~%")
	  (cond
	   ((not *touch-it-server-detected*)
	    (setq *touch-it-server-detected* t)
	    (send touch-it-interface :wait-for-server)))
	  (warning-message 2 "[touch_it_client] finish waiting for server ~%")
	  (setq goal (instance move_base_msgs::MoveBaseActionGoal :init))
	  (send goal :goal :target_pose :header :frame_id frame_id)
	  (send goal :goal :target_pose :header :stamp (ros::time 0.0))
	  (send goal :goal :target_pose :pose :position :x (elt p 0))
	  (send goal :goal :target_pose :pose :position :y (elt p 1))
	  (send goal :goal :target_pose :pose :position :z (elt p 2))
	  (send goal :goal :target_pose :pose :orientation :x (elt q 1))
	  (send goal :goal :target_pose :pose :orientation :y (elt q 2))
	  (send goal :goal :target_pose :pose :orientation :z (elt q 3))
	  (send goal :goal :target_pose :pose :orientation :w (elt q 0))
	  (send goal :goal :target_pose :header :seq (+ (* 10 axis) ik-type))
	  ;; send request
	  (warning-message 2 "[touch_it_client] send goal to server ~%")
	  (send touch-it-interface :send-goal goal)
	  ;; wait
	  (warning-message 2 "[touch_it_client] start waiting for result~%")
	  (ros::rate 10)
	  (while (not (equal (send touch-it-interface :simple-state) ros::*simple-goal-state-done*))
	    (warning-message 2 "[touch_it_client] waiting for result ... ~A~%" (send touch-it-interface :feedback))
	    (when (send touch-it-interface :feedback)
	      (setq feedback-value (send (ros::tf-pose-stamped->coords (send (send touch-it-interface :feedback) :feedback :base_position)) :pos))
	      (setq feedback-value2 (car (rpy-angle (send (ros::tf-pose-stamped->coords (send (send touch-it-interface :feedback) :feedback :base_position)) :rot))))
	      (send self :publish-touchit-status
		    (format nil "force ~5,2f / ~5,2f ~% IK ~a  (~5,2f %)"
			    (elt feedback-value 0) (elt feedback-value 1) (if (eps= (elt feedback-value2 0) 0) "FAIL" "SUCC") (elt feedback-value 2)))
	      )
	    (ros::sleep)
	    (ros::spin-once)
	    ))))
     ;; (warning-message 2 "[touch_it_client] result1: ~a ~%" (send *c* :get-result))
     (setq res (send touch-it-interface :get-state))
     ;; (warning-message 2 "[touch_it_client] result2: ~a ~%" res)
     (send self :publish-touchit-status
	   (if (send touch-it-interface :feedback)
	       (progn
		 (setq feedback-value (send (ros::tf-pose-stamped->coords (send (send touch-it-interface :feedback) :feedback :base_position)) :pos))
		 (format nil
			 (format nil "~A (~a)~%force ~5,2f / ~5,2f  (~5,2f %)"
				 (cond
				  ((equal res *touchit-touched*) "TOUCHED")
				  ((equal res *touchit-reached*) "REACHED")
				  ((equal res *touchit-cancelled*) "CANCELLED"))
				 res
				 (elt feedback-value 0) (elt feedback-value 1) (elt feedback-value 2))))
	     (format nil
		     (format nil "~A (~a)"
			     (cond
			      ((equal res *touchit-touched*) "TOUCHED")
			      ((equal res *touchit-reached*) "REACHED")
			      ((equal res *touchit-cancelled*) "CANCELLED"))
			     res))
	     :scale 0.25))
     res))

  ;; initial pose
  (:init-pose
   nil
   (send *robot* :reset-manip-pose)
   (send self :fix-robot-coords)
   (if (and (boundp '*viewer*) *viewer*)
       (send *viewer* :draw-objects))
   )

  (:fix-robot-coords
   nil
   (send *robot* :fix-leg-to-coords (make-coords) :both)
   (send *real-robot* :fix-leg-to-coords (make-coords) :both)
   )
;;;;;;;; setup ;;;;;;;;;;;

;;;;;;;; controller ;;;;;;;;;
  (:spacenav-subscriber
   (msg
    &optional
    (move-filter '(1 1 1))
    (rpy-filter '(1 1 1)))
   (cond
    ((and (> (aref (send msg :buttons) 0) 0.1)
	  (> (aref (send msg :buttons) 1) 0.1))
     (format t "mouse-mode~%")
     (format t "standby..?~%")
     (setq *mouse-mode* (not *mouse-mode*))
     (print 3) (unix:sleep 1)
     (print 2) (unix:sleep 1)
     (print 1) (unix:sleep 1)
     (format t "start!!~%")
     )
    ((not *mouse-mode*)
     (return-from :spacenav-subscriber nil))
    ((> (aref (send msg :buttons) 1) 0.1)
     (print 'waist-fix)
     (waist-fix :waist-key :waist-r :cnt 3)
     (waist-fix :waist-key :waist-p :cnt 3)
     (waist-fix :waist-key :waist-y :cnt 3)
     (print 'done)
     )
    ((null *success-state-collection*) nil)
    ((> (aref (send msg :buttons) 0) 0.1)
     (print 'pop-back-robot-state)
     (let ((state (pop *success-state-collection*)))
       (send *robot* :angle-vector
	     (cdr (assoc :angle-vector state)))
       (send *robot* :newcoords
	     (cdr (assoc :worldcoords state)))
       (send *viewer* :draw-objects))
     ))
   (let ((move
	  (scale
	   30
	   (coerce
	    (subseq (send msg :axes) 0 3)
	    float-vector)))
	 (rpy
	  (reverse
	   (scale
	    0.12
	    (coerce
	     (subseq (send msg :axes) 3 6)
	     float-vector)))))
     (cond
      ((< (norm
	   (coerce
	    (send msg :axes)
	    float-vector)) 0.01)
       ;; (concatenate
       ;;  float-vector
       ;;  (scale 1e-3 move)
       ;;  rpy)) 0.01)
       (format t "skip ~A ~A~%" move rpy))
      (t
       (setq move
	     (map float-vector
		  #'*
		  move move-filter))
       (setq rpy
	     (map float-vector
		  #'*
		  rpy rpy-filter))
       (if (vectorp
	    (send self :call-ik-server
		  :rotation-axis t
		  :translation-axis t
		  :move-coords
		  (make-coords :pos move :rpy rpy)))
	   (send self :publish-joint-states :real? nil))
       ))))

  (:robot-marker-joint-state-subscriber
   (msg)
   (format t "[robot-marker-joint-state-subscriber] called ")

   (bench
    (let ((joint-names (send msg :name))
	  (joint-angles (send msg :position))
	  joint-name joint-angle
	  buf
	  )
      ;;(describe msg)
      (dotimes (x (length joint-names))
	(setq joint-name (elt joint-names x))
	(let ((joint-method (intern (string-upcase joint-name) *keyword-package*)))
	  (when (find-method *robot* joint-method)
	    (if (subclassp (class (send *robot* joint-method)) rotational-joint)
		(setq joint-angle (rad2deg (elt joint-angles x)))
	      (setq joint-angle (* 1000.0 (elt joint-angles x))))
	    (send *robot* joint-method :joint-angle joint-angle))))
      (send self :fix-robot-coords)
      (when (boundp '*irtviewer*) (send *irtviewer* :draw-objects))
      )))

  (:joint-state-subscriber
   (msg)
   (format t "[joint-state-subscriber] called ")
   (bench
    (let ((joint-names (send msg :name))
	  (joint-angles (send msg :position))
	  joint-name joint-angle
	  buf
	  )

      (dotimes (x (length joint-names))
	(setq joint-name (elt joint-names x))

	(setq joint-angle (rad2deg (elt joint-angles x)))
	(setq buf
	      (intern (string-upcase joint-name) *keyword-package*))
	(if (find-method *real-robot* buf)
	    (send *real-robot* buf :joint-angle joint-angle))
	)
      (send self :fix-robot-coords)

      (case *origin-key*
	(:free nil)
	(t 
	 (let ((from-frame *robot-origin*)
	       (to-frame (if (eq *origin-key* :rarm) *rhand-frame* *lhand-frame*))
               (trans nil))
           (if to-frame
               (setq (send *tfl* :lookup-transform ;pelvis -> grasp_frame
                           from-frame to-frame (ros::time 0.0))))
           (if trans
               (progn
                 (send trans :transform 
                       (send (make-coords) :transformation ;origin -> pelvis
                             (send *real-robot* :copy-worldcoords))
                       :world)
                 (send *origin-coords* :move-to trans :world))
             (send *origin-coords* :move-to
                   (send *real-robot* *origin-key* :end-coords :worldcoords)
                   :world)
             )))
        ))

    
    (when (boundp '*irtviewer*) (send *irtviewer* :draw-objects))
    ))

  (:waist-fix
   (&key
    (waist-key :waist-r)
    (waist-joint (send *robot* :torso waist-key))
    (waist-angle (send waist-joint :joint-angle))
    (angle-target 0)
    (prev-waist-angle waist-angle)
    (move-step 1)
    (target-coords
     (send *robot* *move-limb*
	   :end-coords :copy-worldcoords))
    (cnt 10)
    (ret #F()))
   (while (and (vectorp ret)
	       (> (abs (- waist-angle angle-target))
		  move-step)
	       (plusp (decf cnt)))
     (setq prev-waist-angle waist-angle)
     (setq waist-angle
	   (* (if (> waist-angle 0) 1 -1)
	      (- (abs waist-angle) move-step)))
     (send waist-joint :joint-angle waist-angle)
     (setq ret (send self :call-ik-server ;:target-coords target-coords
		     :rotate? :x)))
   (if (not (vectorp ret))
       (send waist-joint :joint-angle prev-waist-angle)))

  ;;Interactive Marker Callback
  (:marker-menu-callback
   ( msg )
   (let ((menu (send msg :menu))
	 (type (send msg :type)))
     (cond
      ((eq menu jsk_interactive_marker::MarkerMenu::*MOVE*)
       (format t "[marker-menu] move robot!!~%")
       (send self :publish-joint-states :real? t))
      ((eq menu jsk_interactive_marker::MarkerMenu::*SET_ORIGIN*)
       (setq *origin-key* :free)
       (send self :set-origin)
       ;;(send self :publish-joint-states :real? nil)
       )
      ;;reset target coords
      ((eq menu jsk_interactive_marker::MarkerMenu::*RESET_COORDS*)
       (send *target-coords* :move-to *old-coords* :world)
       (send self :set-marker-pose-robot (send *target-coords* :worldcoords))
       )
      ;;reset joint and base
      ((eq menu jsk_interactive_marker::MarkerMenu::*RESET_JOINT*)
       (format t "[marker-menu] reset robot joint!!~%")
       (send self :realmodel2model)
       (send self :publish-joint-states :real? nil)
       ;;reset root pose
       (ros::publish (format nil "~A/~A/reset_root_pose" *im-nodename* *robot-topic-name*)
		     (instance std_msgs::Empty :init))
       (case *move-limb*
	 (:arms
	  )
	 (t
	  (send self :set-origin-to-hand *move-limb*)
	  )))
      ;;set origin to hand
      ((eq menu jsk_interactive_marker::MarkerMenu::*SET_ORIGIN_RHAND*)
       (let ((message "set origin to rhand"))
	 (send self :publish-menu-select message)
	 (format t "[marker-menu] ~A~%" message)
	 )
       ;;(setq *origin-key* :free)
       (setq *origin-key* :rarm)
       (send self :set-origin-to-hand :rarm)
       ;;(send self :publish-joint-states :real? nil)
       )
      ((eq menu jsk_interactive_marker::MarkerMenu::*SET_ORIGIN_LHAND*)
       (let ((message "set origin to lhand"))
	 (send self :publish-menu-select message)
	 (format t "[marker-menu] ~A~%" message)
	 )
       ;;(setq *origin-key* :free)
       (setq *origin-key* :larm)
       (send self :set-origin-to-hand :larm)
       ;;(send self :publish-joint-states :real? nil)
       )
      ;;change ik-rotation-axis
      ((eq menu jsk_interactive_marker::MarkerMenu::*IK_ROTATION_AXIS_T*)
       (let ((message "set ik mode 6D"))
	 (send self :publish-menu-select message)
	 (format t "[marker-menu] ~A~%" message)
	 (setq *rotation-axis* t)
	 )
       )
      ((eq menu jsk_interactive_marker::MarkerMenu::*IK_ROTATION_AXIS_NIL*)
       (let ((message "set ik mode 3D"))
	 (send self :publish-menu-select message)
	 (format t "[marker-menu] ~A~%" message)
	 (setq *rotation-axis* nil)
	 )
       )
      ;;change use-torso
      ((eq menu jsk_interactive_marker::MarkerMenu::*USE_TORSO_T*)
       (setq *use-torso* t)
       (setq *use-fullbody* nil)
       )
      ((eq menu jsk_interactive_marker::MarkerMenu::*USE_TORSO_NIL*)
       (setq *use-torso* nil)
       (setq *use-fullbody* nil)
       )
      ((eq menu jsk_interactive_marker::MarkerMenu::*USE_FULLBODY*)
       (setq *use-torso* nil)
       (setq *use-fullbody* t)
       )
      ;;changeControllArm
      ((eq menu jsk_interactive_marker::MarkerMenu::*SET_MOVE_RARM*)
       (let ((message "move rarm"))
	 (send self :publish-menu-select message)
	 (format t "[marker-menu] ~A~%" message)
	 )
       (setq *move-limb* :rarm)
       (setq *origin-key* :rarm)
       (send self :set-origin-to-hand :rarm)
       )
      ((eq menu jsk_interactive_marker::MarkerMenu::*SET_MOVE_LARM*)
       (let ((message "move larm"))
	 (send self :publish-menu-select message)
	 (format t "[marker-menu] ~A~%" message)
	 )
       (setq *move-limb* :larm)
       (setq *origin-key* :larm)
       (send self :set-origin-to-hand :larm)
       )
      ((eq menu jsk_interactive_marker::MarkerMenu::*SET_MOVE_ARMS*)
       (let ((message "move both arms"))
	 (send self :publish-menu-select message)
	 (format t "[marker-menu] ~A~%" message)
	 )
       (setq *move-limb* :arms)
       )
      ((eq menu jsk_interactive_marker::MarkerMenu::*PUBLISH_MARKER*)
       (send self :publish-target-arrow-obj)
       (send self :publish-origin-arrow-obj)
       )
      ((eq menu jsk_interactive_marker::MarkerMenu::*PLAN*)
       (let ((message "start IK"))
	 (send self :publish-menu-select message)
	 (format t "[marker-menu] ~A~%" message)
	 )
       (setq *ik-stop* nil)
       (setq *publish-ik* t)
       )
      ((eq menu jsk_interactive_marker::MarkerMenu::*CANCEL_PLAN*)
       (let ((message "stop IK"))
	 (send self :publish-menu-select message)
	 (format t "[marker-menu] ~A~%" message)
	 )
       (setq *ik-stop* t)
       (setq *publish-ik* nil)
       (send self :publish-ik-status (format nil " IK STOP") :status :WARNING)
       )

      ;;grasp
      ((eq menu jsk_interactive_marker::MarkerMenu::*START_GRASP*)
       (let ((message "start grasp"))
	 (send self :publish-menu-select message)
	 (format t "[marker-menu] ~A~%" message)
	 )
       (send self :start-grasp :arm *move-limb*)
       )
      ((eq menu jsk_interactive_marker::MarkerMenu::*STOP_GRASP*)
       (let ((message "stop grasp"))
	 (send self :publish-menu-select message)
	 (format t "[marker-menu] ~A~%" message)
	 )
       (send self :stop-grasp :arm *move-limb*)
       )

      ((eq menu jsk_interactive_marker::MarkerMenu::*TOUCHIT_EXEC*)
       (format t "[marker-menu] touch it exec~%")
       (send self :call-touch-it-server :exec)
       )
      ((eq menu jsk_interactive_marker::MarkerMenu::*TOUCHIT_PREV*)
       (format t "[marker-menu] touch it prev~%")
       ;;(send self :call-touch-it-server :prev)
       )
      ((eq menu jsk_interactive_marker::MarkerMenu::*TOUCHIT_CANCEL*)
       (format t "[marker-menu] touch it cancel~%")
       (send self :call-touch-it-server :cancel)
       )
      ((eq menu jsk_interactive_marker::MarkerMenu::*LOOK_RARM*)
       (format t "[marker-menu] look rarm~%")
       (look-hand :rarm :rotate 0)
       (send self :publish-joint-states :real? nil)
       )
      ((eq menu jsk_interactive_marker::MarkerMenu::*LOOK_LARM*)
       (format t "[marker-menu] look larm~%")
       (look-hand :larm :rotate 0)
       (send self :publish-joint-states :real? nil)
       )
      )
     (when (boundp '*irtviewer*)
       (send *irtviewer* :draw-objects))
     )
   (send self :set-marker-pose-robot (send *target-coords* :worldcoords))
   (send self :publish-arrow-tf)
   (send self :publish-status)
   )

  (:robot-marker-menu-callback
   ( msg )
   (let ((menu (send msg :menu))
	 (type (send msg :type)))
     (cond
      ((eq menu jsk_interactive_marker::MarkerMenu::*MOVE*)
       (format t "[marker-menu] move robot base!!~%")
       (send self :publish-base-target))
      ((eq menu jsk_interactive_marker::MarkerMenu::*JOINT_MOVE*)
       (format t "[marker-menu] move robot joint!!~%")
       (send self :publish-joint-states :real? t))
      ((eq menu jsk_interactive_marker::MarkerMenu::*RESET_JOINT*)
       (format t "[marker-menu] reset robot joint!!~%")
       (send self :realmodel2model)
       (send self :publish-joint-states :real? nil))
      ((eq menu 100)
       (format t "[marker-menu] stand-pose~%")
       (if (find-method *robot* :stand-pose)
	   (send *robot* :stand-pose))
       (send self :publish-joint-states :real? nil))
      ((eq menu 101)
       (format t "[marker-menu] reset-manip-pose~%")
       (if (find-method *robot* :reset-manip-pose)
	   (send *robot* :reset-manip-pose))
       (send self :publish-joint-states :real? nil))
      (t (format t "[marker-menu] unknonw(~A)~%" menu))
      ))
   (send self :publish-status)
   )

  ;;called when marker is moved
  (:pose-callback
   (msg)
   (let* ((pose (send msg :pose))
	  (cds (ros::tf-pose-stamped->coords pose))
	  map->marker
	  )
     (setq cds (send self :get-eus-coords cds (send pose :header :frame_id)))
     (send *target-coords* :move-to (send (car (send *real-robot* :links)) :copy-worldcoords) :world)
     (send *target-coords* :transform cds :local)

     ;;set *tmp-rotation-axis*
     (cond
      ((equal (send msg :type) jsk_interactive_marker::MarkerPose::*SPHERE_MARKER*)
       (setq *tmp-rotation-axis* nil))
      (t
       (setq *tmp-rotation-axis* t)))
     (when (boundp '*irtviewer*)
       (send *irtviewer* :draw-objects))
     )
   (send self :update-target-coords)
   )

  (:update-target-coords
   ()
   (send self :publish-arrow-tf)
   (send self :publish-hand-marker-pose)
   (setq *target-update-times* (1+ *target-update-times*))
   )

  (:publish-hand-marker-pose
   ()
   (let ((ps-msg (instance geometry_msgs::PoseStamped :init))
         hand-coords)

     (setq hand-coords (send (send self :get-base-coords) :transformation *target-coords* :local))
     (setq ps-msg (ros::coords->tf-pose-stamped hand-coords *frame-id*))
     (ros::publish (format nil "~A/l_gripper/set_pose" *gripper-im-nodename*)
                   ps-msg)
     )
   )

  (:tf-end-coords
   (&optional (arm :rarm))
   (let* ((from-frame *robot-origin*)
	  (to-frame (if (eq arm :rarm) *rhand-frame* *lhand-frame*))
	  (trans nil))
     (if to-frame
         (setq trans (send *tfl* :lookup-transform ;pelvis -> grasp_frame
                           from-frame to-frame (ros::time 0.0))))
     (cond
      (trans
       (send trans :transform
             (send (make-coords) :transformation ;origin -> pelvis
                   (send *real-robot* :copy-worldcoords))
             :world)
       trans)
      (t (send *real-robot* arm :end-coords :copy-worldcoords)))))

  
  (:tf-model-end-coords
   (&key
    (robot *robot*)
    (limb :rarm)
    )
   (let* ((real-end-coords (send self :tf-end-coords limb))
	  (wrist2end (send (copy-object
			    (send
			     (send *real-robot* limb :end-coords :parent)
			     :worldcoords))
			   :transformation
			   real-end-coords)))
     (send (copy-object
	    (send
	     (send *robot* limb :end-coords :parent)
	     :worldcoords))
	   :transform wrist2end :local)))

  (:set-origin
   ()
   (send self :realmodel2model)
   (setq *old-coords* (send *target-coords* :copy-worldcoords))
   (send *origin-coords* :move-to *target-coords* :world)
   )

  (:set-origin-to-hand
   (&optional (arm :rarm))
   (send self :realmodel2model)
   (send *target-coords* :move-to
	 (send self :tf-end-coords arm)
	 :world)
   (send self :set-origin)
   (send self :set-marker-pose-robot (send *target-coords* :worldcoords))
   )

  (:realmodel2model
   ()
   (let (res)
     (setq res (ros::service-call (format nil "~A/~A/get_joint_states" *im-nodename* *robot-topic-name*) (instance jsk_interactive_marker::GetJointStateRequest :init)))

     (let* ((res-joint-state (send res :joint_state))
	    (joint-names (send res-joint-state :name))
	    (joint-angles (send res-joint-state :position))
	    joint-name joint-angle
	    )
       (dotimes (x (length joint-names))
	 (setq joint-name (elt joint-names x))
	 (let ((joint-method (intern (string-upcase joint-name) *keyword-package*)))
	   (when (find-method *real-robot* joint-method)
	     (if (subclassp (class (send *robot* joint-method)) rotational-joint)
		 (setq joint-angle (rad2deg (elt joint-angles x)))
	       (setq joint-angle (* 1000.0 (elt joint-angles x)))))
	   (send *real-robot* joint-method :joint-angle joint-angle)))
       )

     (send *robot*
	   :angle-vector
	   (copy-object
	    (send *real-robot* :angle-vector)))
     (send self :fix-robot-coords)
     )
   )

  ;;fixed flame is foot?
  (:get-base-coords
   ()
   (let (coords torso->map)
     ;;(setq coords (send *real-robot* :copy-worldcoords))
     (setq coords (send (car (send *real-robot* :links)) :copy-worldcoords))
     (while t
       (setq torso->map
	     (send *tfl* :lookup-transform
		   ;;"r_foot" "map" (ros::time 0)))
		   *robot-origin* *frame-id* (ros::time 0)))
       (cond
	(torso->map
	 (send coords :transform torso->map)
	 (return)
	 )
	(t
	 (ros::ros-info "~A -> ~A cannot transform yet" *robot-origin* *frame-id*)
	 (unix:sleep 1)
	 )
	)
       )
     coords
     )
   )

  (:set-marker-pose
   (coords &key (marker-name) (frame *frame-id*) (markers) (server *server-nodename*))
   (let ((req (instance jsk_interactive_marker::MarkerSetPoseRequest :init))
	 (msg (ros::coords->tf-pose-stamped coords frame))
	 (ps (instance geometry_msgs::PoseStamped :init)))
     (send req :marker_name marker-name)
     (send req :pose msg)
     (send req :markers markers)
     (ros::service-call (format nil "~A/set_pose" server)
			req)

     ;;publish set pose
     (send ps :pose msg)
     (send ps :header :frame_id frame)
     (ros::publish (format nil "~A/set_pose" *server-nodename*)
		   msg)     
     ))

  (:set-marker-pose-robot
   (coords &rest args)
   (if args
       (apply #'send self :set-marker-pose
	      (append
	       (list
		(send (send self :get-base-coords)
		      :transformation coords :local)
		args)))
     (send self :set-marker-pose
           (send (send self :get-base-coords) :transformation coords :local))
     ))

  (:publish-arrow-tf
   ()
   (send *tfb* :send-transform
	 (send (send self :get-base-coords) :transformation
	       *target-coords* :local)
	 *frame-id* "/im_target_coords_arrow")
   (send *tfb* :send-transform
	 (send (send self :get-base-coords) :transformation
	       *origin-coords* :local)
	 *frame-id* "/im_origin_coords_arrow")
   )

  (:publish-target-arrow-obj
   ()
   (let ((org  (send *target-coords* :copy-worldcoords)))
     (send *target-coords* :reset-coords)
     (send *target-coords* :worldcoords)
     (send-all (send *target-coords* :bodies) :worldcoords)
     (ros::publish (format nil "~A/marker" *server-nodename*)
		   (object->marker-msg *target-coords*
				       (instance std_msgs::header :init
						 :frame_id "/im_target_coords_arrow")))
     (send *target-coords* :transform org)
     (send *target-coords* :worldcoords)
     )
   )

  (:publish-origin-arrow-obj
   ()
   (let ((org  (send *origin-coords* :copy-worldcoords)))
     (send *origin-coords* :reset-coords)
     (send *origin-coords* :worldcoords)
     (send-all (send *origin-coords* :bodies) :worldcoords)
     (ros::publish (format nil "~A/origin_marker" *server-nodename*)
		   (object->marker-msg *origin-coords*
				       (instance std_msgs::header :init
						 :frame_id
						 "/im_origin_coords_arrow")))
     (send *origin-coords* :transform org)
     (send *origin-coords* :worldcoords)
     )
   )

  (:publish-menu-select
   (text &key (scale 0.15))
   (let ((marker (instance visualization_msgs::marker :init)))
     (send marker :header :frame_id "/im_target_coords_arrow")
     (send marker :id 2)
     (send marker :lifetime (ros::time 5))
     (send marker :pose :position :z 1.05)
     (send marker :pose :orientation :w 1)
     (send marker :color :r 1)
     (send marker :color :g 1)
     (send marker :color :a 1)
     (send marker :scale :z scale)
     (send marker :type visualization_msgs::marker::*TEXT_VIEW_FACING*)
     (send marker :text text)
     (ros::publish (format nil "~A/marker" *server-nodename*) marker)
     )
   )

  (:publish-touchit-status
   (text &key (scale 0.15))
   (let ((marker (instance visualization_msgs::marker :init)))
     (send marker :header :frame_id "/im_target_coords_arrow")
     (send marker :id 1)
     (send marker :lifetime (ros::time 5))
     (send marker :pose :position :z 1.05)
     (send marker :pose :orientation :w 1)
     (send marker :color :r 1)
     (send marker :color :g 1)
     (send marker :color :a 1)
     (send marker :scale :z scale)
     (send marker :type visualization_msgs::marker::*TEXT_VIEW_FACING*)
     (send marker :text text)
     (ros::publish (format nil "~A/marker" *server-nodename*) marker)
     )
   )

  (:overlay-text-color
   (status &key (a 0.8))
   (let ((color (instance std_msgs::ColorRGBA :init)))
     (case status
       (:INFO
        (send color :r (/ 25 255.0))
        (send color :g (/ 255 255.0))
        (send color :b (/ 255 255.0))
        )
       (:WARNING
        (send color :r (/ 255 255.0))
        (send color :g (/ 255 255.0))
        (send color :b (/ 0 255.0))
        )
       (:ERROR
        (send color :r (/ 255 255.0))
        (send color :g (/ 0 255.0))
        (send color :b (/ 0 255.0))
        )
       )
     (send color :a a)
     color
     ))

  (:publish-ik-status
   (text &key (delete nil) (status :INFO) (text_size 20))
   (let ((text_msg (instance jsk_rviz_plugins::OverlayText :init)))
     (if delete
         (send text_msg :action jsk_rviz_plugins::OverlayText::*DELETE*)
       (send text_msg :action jsk_rviz_plugins::OverlayText::*ADD*)
       )
     (send text_msg :width 640)
     (send text_msg :height 100)
     (send text_msg :fg_color (send self :overlay-text-color status))
     (send text_msg :bg_color :a 0.2)
     (send text_msg :line_width 2)
     (send text_msg :text_size 64)
     (send text_msg :font "DejaVu Sans Mono")
     (send text_msg :text text)
     (ros::publish (format nil "~A/ik_status" *nodename*) text_msg)
     ))


  (:publish-status
   (&key (delete nil) (status :INFO) (text_size 20))
   (let ((text_msg (instance jsk_rviz_plugins::OverlayText :init))
         text)
     (setq text (concatenate string
                             (format nil " ik:            ~A~%" (if *ik-stop* "stop" "running"))
                             (format nil " move-arm:      ~A~%" *move-limb*)
                             (format nil " target-coords: ~A~%" *origin-key*)
                             (format nil " ik-mode:       ~A~%" (if *rotation-axis* "6D" "3D"))
                             (format nil " move-link:     ~A~%" (cond (*use-torso* "torso")
                                                                      (*use-fullbody* "fullbody")
                                                                      (t "arm")
                                                                      ))
                             (format nil " ik-update:     ~A~%" *ik-update-times*)
                             (format nil " target-update: ~A~%" *target-update-times*)
                             ))
     (if delete
         (send text_msg :action jsk_rviz_plugins::OverlayText::*DELETE*)
       (send text_msg :action jsk_rviz_plugins::OverlayText::*ADD*)
       )
     (send text_msg :width 400)
     (send text_msg :height 240)
     (send text_msg :top 104)
     (send text_msg :fg_color (send self :overlay-text-color status))
     (send text_msg :bg_color :a 0.2)
     (send text_msg :line_width 2)
     (send text_msg :text_size 20)
     (send text_msg :font "DejaVu Sans Mono")
     (send text_msg :text text)
     (ros::publish (format nil "~A/status" *nodename*) text_msg)
     ))


  (:publish-joint-states
   (&key
    (real? nil))
   (let ((joint-list
          (append (send *robot* :joint-list)
                  ))
         (joint-state-msg
          (instance sensor_msgs::JointState :init
                    :header (instance std_msgs::header :init
                                      :stamp (ros::time-now))))
         (set-pose-msg
          (instance geometry_msgs::PoseStamped :init
                    :header (instance std_msgs::header :init
                                      :stamp (ros::time-now)
                                      :frame_id *robot-origin*)))
         )
     (send joint-state-msg :position
           (mapcar #'(lambda (joint) (send joint :ros-joint-angle)) joint-list))
     (send joint-state-msg :name (send-all joint-list :name))

     ;;set set-pose-msg
     (send set-pose-msg :pose
           (ros::coords->tf-pose
            (send (send (car (send *real-robot* :links)) :copy-worldcoords) :transformation
                  (send (car (send *robot* :links)) :copy-worldcoords)
                  :local)))

     (cond
      (real?
       (ros::publish (format nil "~A/~A/joint_states_ri_move" *im-nodename* *robot-topic-name*)
                     joint-state-msg)

       )
      (t
       (ros::publish (format nil "~A/~A/reset_joint_states" *im-nodename* *robot-topic-name*)
                     joint-state-msg)
       (ros::publish (format nil "~A/~A/set_pose" *im-nodename* *robot-topic-name*)
                     set-pose-msg)
       ))
     )
   )

  (:publish-joint-trajectory
   (avs &optional (tms (list 3000)) &key
	(real? nil))
   (let (joint-list
	 (joint-traj-msg
	  (instance trajectory_msgs::JointTrajectory :init
		    :header (instance std_msgs::header :init
				      :stamp (ros::time-now))))
	 (now-av (send *robot* :angle-vector))
	 points
	 (time-total 0)
	 )

     (if (atom tms) (setq tms (make-list (length avs) :initial-element tms)))
     (if (< (length tms) (length avs))
	 (setq tms (append tms (make-list (- (length avs) (length tms)) :initial-element (car (last tms))))))

     (dotimes (i (length avs))
       (let ((jtp (instance trajectory_msgs::JointTrajectoryPoint :init))
	     time
	     )
	 (send *robot* :angle-vector (elt avs i))
	 (setq joint-list (send *robot* :joint-list))
	 (send jtp :positions (mapcar #'(lambda (joint) (send joint :ros-joint-angle)) joint-list))

	 (setq time (elt tms i))
	 (setq time-total (+ time-total time))
	 (send jtp :time_from_start (ros::time (/ time-total 1000.0)))
	 (push jtp points)
	 ))
     (setq points (reverse points))

     (send joint-traj-msg :joint_names (send-all joint-list :name))
     (send joint-traj-msg :points points)

     (cond
      (real?
       (ros::publish (format nil "~A/~A/joint_trajectory_ri_move" *im-nodename* *robot-topic-name*)
		     joint-traj-msg))
      ))
   )


  (:publish-base-target
   ()
   (when *base-target-coords*
     (let ((base-msg (ros::coords->tf-pose-stamped *base-target-coords* (send *base-target-coords* :name))))
       (ros::publish (format nil "~A/~A/base_move" *im-nodename* *robot-topic-name*)
		     base-msg)
       )
     )
   )

  (:base-target-callback
   (msg)
   (setq *base-target-coords* (ros::tf-pose-stamped->coords msg))
   (print "update target")
   )

  (:grasp-pose-callback
   (msg)
   (setq hoge msg)
   (when *movingp*
     (ros::ros-error "still moving")
     (return-from :grasp-pose-callback nil))
   (setq *movingp* t)
   ;;grasp
   (let* ((pose msg)
	  (cds (ros::tf-pose-stamped->coords msg))
	  map->marker
	  pre-pose
	  )
     (setq cds (send self :get-eus-coords cds (send pose :header :frame_id)))
     (send *target-coords* :move-to (send (car (send *real-robot* :links)) :copy-worldcoords) :world)
     (send *target-coords* :transform cds :local)

     (send *target-coords* :translate (float-vector 10 0 0)) ; move a little bit forward
     (setq *tmp-rotation-axis* t)
     (dotimes (i 2)
       (send self :stop-grasp :arm *one-click-grasp-arm*)
       (unix:sleep 1))
     (let (avs time-sequences)
       (send *robot* *one-click-grasp-arm* :move-end-pos (float-vector -100 0 0))
       (send *robot* *one-click-grasp-arm* :move-end-pos (float-vector -50 0 0))
       (push (send *robot* :angle-vector) avs)

       (setq pre-pose (send (send *target-coords* :copy-worldcoords) :translate (float-vector -100 0 0)))
       (send pre-pose :translate (float-vector 0 0 50) :world)
       (when (> (abs (v. (send pre-pose :x-axis) (float-vector 0 0 1))) 0.5) ;??
         (send pre-pose :translate (float-vector 0 0 50) :world)
         (send pre-pose :translate (float-vector -30 0 0))
         )
       (unless (send *robot* :inverse-kinematics
                     pre-pose
                     :move-target (send *robot* *one-click-grasp-arm* :end-coords)
		     :use-torso t
                     :rotation-axis t
                     :debug-view t)
         (send pre-pose :rotate (deg2rad -180) :x)
         (if (send *robot* :inverse-kinematics
                   pre-pose
		   :move-target (send *robot* *one-click-grasp-arm* :end-coords)   
                   :use-torso t
                   :rotation-axis t
                   :debug-view t)
             (progn
               (send *target-coords* :rotate (deg2rad -180) :x)
               )
           (progn
             (setq *movingp* nil)
             (return-from :grasp-pose-callback nil)
             )))
       (push (send *robot* :angle-vector) avs)

       (unless (send *robot* :inverse-kinematics
                     *target-coords*
                     :move-target (send *robot* *one-click-grasp-arm* :end-coords) 
                     :use-torso t
                     :rotation-axis t
                     :debug-view t)
         (setq *movingp* nil)
         (return-from :grasp-pose-callback nil))
       (print 'bbb)
       (push (send *robot* :angle-vector) avs)

       (setq avs (reverse avs))
       (cond 
	((equal (string-upcase *robot-name*) "BAXTER")
	 (setq time-sequences  (list 2000 5000 2000)))
	(t
	 (setq time-sequences  (list 500 500 500))))
       (send self :publish-joint-trajectory avs time-sequences :real? t)
       )
     (unix:usleep (* 1000 (+ 500 500 500)))
     (send self :start-grasp :arm *one-click-grasp-arm*)
     (unix:usleep (* 1000 1000))
     (let (avs time-sequences)
       ;; pick up and place
       (push (send *robot* :angle-vector) avs)
       (send *robot* *one-click-grasp-arm* :move-end-pos #f(0 0 100) :world)
       (push (send *robot* :angle-vector) avs)
       
       (send *target-coords* :locate #f(0 0 -100) :world)
       (cond 
	((equal (string-upcase *robot-name*) "BAXTER")
	 (setq time-sequences  (list 3000 3000)))
	(t
	 (setq time-sequences  (list 1000 1000))))
       (send self :publish-joint-trajectory avs time-sequences :real? t)
       )

     (when (boundp '*irtviewer*)
       (send *irtviewer* :draw-objects))
     )
   (send self :publish-arrow-tf)
   (setq *movingp* nil)
   )

  (:apply-joint-state
   (model joint-state)
   (dotimes (i (length (send joint-state :name)))
     (let ((joint-name (elt (send joint-state :name) i))
	   (joint-angle (elt (send joint-state :position) i)))
       (when (find-method model (intern (string-upcase joint-name) *keyword-package*))
	 (send model (intern (string-upcase joint-name) *keyword-package*) :ros-joint-angle joint-angle)
	 )
       )
     )
   )

  (:move-model-callback
   (msg)
   (require "models/room73b2-scene.l")
   (ros::ros-info "move-model-callback")
   (print-ros-msg msg)
   (setq move-model msg)
   ;;set model
   (cond
    ((functionp (read-from-string (send msg :description)))
     (setq model (funcall (read-from-string (send msg :description)))))
    (t
     (ros::ros-error "model is undefined : ~A" (send msg :description))
     (return-from :move-model-callback nil))
    )
   (setq model-origin (copy-object model))
   (setq model-goal (copy-object model))

   (setq handle (copy-object (send model :handle)))
   (dolist (one-handle (send model :handle))
     (if (find-method model (read-from-string (string-upcase (send one-handle :name))))
	 (send  (send model (read-from-string (string-upcase (send one-handle :name))) :child-link) :assoc one-handle)
       )
     )

   (send model-origin :move-to (send self :pose-stamped->coords (send msg :pose_origin)) :world)
   (send model-goal :move-to (send self :pose-stamped->coords (send msg :pose_goal)) :world)
   (send model :move-to (send self :pose-stamped->coords (send msg :pose_goal)) :world)
   (send *robot* :move-to (send self :pose-stamped->coords (ros::coords->tf-pose-stamped (make-coords) *robot-origin*)) :world)

   (send self :apply-joint-state model-origin (send msg :joint_state_origin))
   (send self :apply-joint-state model-goal (send msg :joint_state_goal))

   (setq joint-num (length (send model-origin :joint-list)))

   ;;check move joint
   (setq move-joint (make-list joint-num :initial-element nil))
   (dotimes (i joint-num)
     (setq angle-origin (send (elt (send model-origin :joint-list) i) :joint-angle))
     (setq angle-goal (send (elt (send model-goal :joint-list) i) :joint-angle))

     (cond
      ((derivedp (elt (send model-origin :joint-list) i) rotational-joint)
       (if (> (abs (- angle-origin angle-goal)) 5) ;; 5 degree
	   (setf (elt move-joint i) t)
	 ))
      ((derivedp (elt (send model-origin :joint-list) i) linear-joint)
       (if (> (abs (- angle-origin angle-goal)) 50) ;; 50 mm
	   (setf (elt move-joint i) t)
	 ))
      ))

   (print move-joint)
   (send model :move-to (send model-goal :copy-worldcoords) :world)

   (objects (list model model-origin model-goal *robot*))
   (dotimes (i joint-num)
     (when (elt move-joint i)
       (setq grasp-handle nil)
       (dolist (one-handle (send model :handle))
	 (when (equal (send one-handle :parent) (send (elt (send model :joint-list) i) :child-link))
	   (setq grasp-handle one-handle)
	   (return)
	   ))

       (setq angle-origin (send (elt (send model-origin :joint-list) i) :joint-angle))
       (setq angle-goal (send (elt (send model-goal :joint-list) i) :joint-angle))
       (setq interpolation-num 10)
       (setq grasp-handle-list nil)
       (dotimes (j (1+ interpolation-num))
	 (send (elt (send model :joint-list) i) :joint-angle
	       (+ (* (/ (- angle-goal angle-origin) interpolation-num) j) angle-origin))

	 (push (send (send  grasp-handle :copy-worldcoords) :rotate pi :z) grasp-handle-list)
	 )
       (setq grasp-handle-list (reverse grasp-handle-list))
       (send self :move-model-ik grasp-handle-list)
       )
     )
   (objects (list model model-origin model-goal *robot*))
   )
  
  (:move-model-ik
   (grasp-handle-list)
   (setq ik-args
	 (list :use-base 0.01
	       :use-torso t
	       :base-range (list :min #f(-10000 -10000 -10000) :max #f(10000 10000 10000))
	       :debug-view nil
	       ))
   (dotimes (loop-times 2)
     (let (first-handle
	   handle-vec
	   (offset-length 500)
	   initial-vec
	   initial-rot
	   initial-coords)

       ;; move *robot* in front of grasp object
       ;; initial position for ik
       (setq first-handle (send (car grasp-handle-list) :copy-worldcoords))
       (setq handle-vec (normalize-vector (send first-handle :rotate-vector #f(1 0 0))))

       (setq initial-vec (v- (send first-handle :worldpos) (scale offset-length handle-vec)))
       (setq initial-vec (float-vector (elt initial-vec 0) (elt initial-vec 1) 0))
       (setq initial-rot (atan2 (elt handle-vec 1) (elt handle-vec 0)))

       (setq initial-coords (make-coords :pos initial-vec
					 :rot (rotate-matrix (unit-matrix 3) initial-rot :z)))
       (send *robot* :move-to initial-coords :world)
       )

     (setq test-ik-index (list 0 5 10 5 0))
     (dolist (i test-ik-index)
       (send* *robot* :rarm
	      :inverse-kinematics (elt grasp-handle-list i)
	      :use-base 0.1 ;;parameter
	      ik-args)
       (when (boundp '*irtviewer*)
	 (send *irtviewer* :draw-objects))

       )

     (dolist (i test-ik-index)
       (send* *robot* :rarm
	      :inverse-kinematics (elt grasp-handle-list i)
	      :use-base 0.01 ;;parameter
	      ik-args)
       (when (boundp '*irtviewer*)
	 (send *irtviewer* :draw-objects))

       )

     (dolist (i test-ik-index)
       (send* *robot* :rarm
	      :inverse-kinematics (elt grasp-handle-list i)
	      :use-base 0.001 ;;parameter
	      ik-args)
       (when (boundp '*irtviewer*)
	 (send *irtviewer* :draw-objects))
       )
     
     ;;move-to
     (unless (boundp '*ri*)
       (setq *ri* (instance pr2-interface :init)))

     ;;tuck arm
     (pr2-tuckarm-pose)
     ;;move to
     (send *ri* :move-to (send *robot* :worldcoords) :frame-id *frame-id*)
     (send *robot* :move-to (send self :pose-stamped->coords (ros::coords->tf-pose-stamped (make-coords) *robot-origin*)) :world)

     ;;ik
     (send *robot* :head :look-at (send (car grasp-handle-list) :worldpos))
     (send *ri* :angle-vector (send *robot* :angle-vector) 3000)
     (send *ri* :wait-interpolation)
     (ros::ros-info "sleep for nearest bounding box")
     (unix::sleep 7)
     (ros::ros-info "sleep end for nearest bounding box")
     ;;get nearest bounding box and modify grasp-handle-list
     (let ((req (instance jsk_pcl_ros::NearestBoundingBoxRequest :init))
	   req-pose-stamped
	   res
	   nearest-grasp-coords)

       (setq req-pose-stamped (ros::coords->tf-pose-stamped (car grasp-handle-list) *frame-id*))
       (send req :header (send req-pose-stamped :header))
       (send req :pose (send req-pose-stamped :pose))
       (send req :max_distance 0.300)

       (setq res (ros::service-call "get_nearest_bounding_box" req))
       (print-ros-msg res)
       ;;try once more
       (when (equal (send res :box :header :frame_id) "")
	 (unix::sleep 3)
	 (setq res (ros::service-call "get_nearest_bounding_box" req)))
       (cond
	((equal (send res :box :header :frame_id) "")
	 (return)
	 )
	(t
	 (setq grasp-offset (float-vector 30 0 0))

	 ;;revert grasp offset
	 (unless (eq loop-times 0)
	   (dolist (grasp-handle grasp-handle-list)
	     (send grasp-handle :translate (scale -1 grasp-offset) :local))
	   )

	 (print "get nearest bounding box")
	 (setq nearest-grasp-coords
	       (send self :pose-stamped->coords (instance geometry_msgs::PoseStamped :init :header (send res :box :header) :pose (send res :box :pose))))
	 (setq offset-vector (v- (send nearest-grasp-coords :worldpos) (send (car grasp-handle-list) :worldpos)))
	 (setf (elt offset-vector 2) 0) ;;ignore z offset
	 (print offset-vector)
	 (dolist (grasp-handle grasp-handle-list)
	   (send grasp-handle :translate offset-vector :world))

	 ;;in order to grasp tightly
	 (dolist (grasp-handle grasp-handle-list)
	   (send grasp-handle :translate grasp-offset :local))
	 )
	)))
   
   ;;reset pose
   (send *robot* :reset-pose)
   (send *ri* :angle-vector (send *robot* :angle-vector) 3000)
   (send *ri* :wait-interpolation)

   (setq avs nil)
   (dolist (grasp-handle grasp-handle-list)
     (if
	 (send* *robot* :rarm
		:inverse-kinematics grasp-handle
		:use-base nil ;;parameter
		ik-args)
	 (push (send *robot* :angle-vector) avs)
       (return)
       )
     )
   (setq avs (reverse avs))

   (when avs
     (send *ri* :stop-grasp :rarm :wait t)
     (send *robot* :angle-vector (elt avs 0))
     (send *robot* :rarm :move-end-pos #f(-200 0 0))
     (send *ri* :angle-vector (send *robot* :angle-vector) 5000)
     (send *ri* :wait-interpolation)
     (send *robot* :angle-vector (elt avs 0))
     (send *ri* :angle-vector (send *robot* :angle-vector) 3000)
     (send *ri* :wait-interpolation)
     (send *ri* :start-grasp :rarm)
     )

   (send *ri* :angle-vector-sequence avs 1000)
   (send *ri* :wait-interpolation)
   (when (boundp '*irtviewer*)
     (send *irtviewer* :draw-objects))
   )

  
  ;;TODO
  (:move-object-callback
   (msg)
   (setq hoge msg)
   ;;grasp
   (let* ((pose msg)
	  (cds (ros::tf-pose-stamped->coords msg))
	  map->marker
	  pre-pose
	  )
     (while t
       (send pose :header :stamp (ros::time 0.0)) ;cheat!
       (setq map->marker
	     (send *tfl* :lookup-transform
		   *robot-origin* (send pose :header :frame_id) (ros::time 0)))
       (cond
	(map->marker
	 (send cds :transform map->marker :world)
	 (return)
	 )
	(t
	 (ros::ros-info "~A -> ~A cannot transform yet" *robot-origin* (send pose :header :frame_id))
	 (ros::sleep)
	 )
	)
       )

     (let (avs)
       (ros::ros-info "move-object-callback")
       (send *robot* :inverse-kinematics
	     cds
	     :move-target (send *robot* *one-click-grasp-arm* :end-coords)         
             :use-torso nil
	     :rotation-axis t
	     :debug-view t)
       (push (send *robot* :angle-vector) avs)
       (send *robot* *one-click-grasp-arm* :move-end-pos #f(-100 0 0))
       (push (send *robot* :angle-vector) avs)       
       (send self :publish-joint-trajectory avs (list 3000 1000) :real? t)
       )
     (send self :stop-grasp :arm *one-click-grasp-arm*)
     )
   )

  (:get-eus-coords
   (cds frame-id)
   (let (origin->frame
	 )
     (while t
       (setq origin->frame
	     (send *tfl* :lookup-transform
		   *robot-origin* frame-id (ros::time 0)))
       (cond
	(origin->frame
	 (send cds :transform origin->frame :world)
	 (return)
	 )
	(t
	 (ros::ros-info "~A -> ~A cannot transform yet" *robot-origin* frame-id)
	 (ros::sleep)
	 ))))
   cds
   )

  (:pose-stamped->coords
   (pose-stamped)
   (let ((cds (ros::tf-pose-stamped->coords pose-stamped)))
     (while t
       (setq frame-id->ps-frame-id
	     (send *tfl* :lookup-transform
		   *frame-id* (send pose-stamped :header :frame_id) (ros::time 0)))
       (cond
	(frame-id->ps-frame-id
	 (send cds :transform frame-id->ps-frame-id :world)
	 (send cds :name *frame-id*)
	 (return)
	 )
	(t
	 (ros::ros-info "~A -> ~A cannot transform yet" *frame-id* (send pose-stamped :header :frame_id))
	 (ros::sleep)
	 )
	)
       )
     cds
     )
   )

  (:box-movement-callback
   (msg)
   (setq hoge msg)
   ;;grasp
   (let* ((pose msg)
	  start-cds
	  des-cds
	  (handle-pose (ros::tf-pose->coords (send msg :handle_pose)))
	  box-cds
	  )
     (setq start-cds (send self :get-eus-coords (ros::tf-pose->coords (send msg :box :pose)) (send msg :box :header :frame_id)))
     (setq des-cds (send self :get-eus-coords (ros::tf-pose->coords (send msg :destination :pose)) (send msg :destination :header :frame_id)))

     (setq start-cds (send start-cds :transform handle-pose))
     (setq des-cds (send des-cds :transform handle-pose))

     (setq a (send start-cds :copy-worldcoords))
     (setq b (send des-cds :copy-worldcoords))

     (let (avs)
       ;;pre grasp
       (print "pre grasp")
       (send start-cds :translate #f(-100 0 0))
       (print start-cds)
       (send *robot* :inverse-kinematics
	     start-cds
	     :move-target (send *robot* :rarm :end-coords)
	     :use-torso nil
	     :rotation-axis t
	     :debug-view t)
       (push (send *robot* :angle-vector) avs)
       ;;grasp
       (print "grasp")
       (send start-cds :translate #f(100 0 0))
       (print start-cds)
       (send *robot* :inverse-kinematics
	     start-cds
	     :move-target (send *robot* :rarm :end-coords)
	     :use-torso nil
	     :rotation-axis t
	     :debug-view t)
       (push (send *robot* :angle-vector) avs)
       (setq avs (reverse avs))
       (send self :publish-joint-trajectory avs (list 3000 1000) :real? t)
       (unix::sleep 3)
       (send self :start-grasp :arm :rarm)
       (unix::sleep 3)
       )

     (let (avs)
       ;;raise
       (print "raise")
       (send start-cds :translate #f(0 0 100) :world)
       (print start-cds)
       (send *robot* :inverse-kinematics
	     start-cds
	     :move-target (send *robot* :rarm :end-coords)
	     :use-torso nil
	     :rotation-axis t
	     :debug-view t)
       (push (send *robot* :angle-vector) avs)

       (print "pre place")
       (send des-cds :translate #f(0 0 100) :world)
       (print des-cds)
       (send *robot* :inverse-kinematics
	     des-cds
	     :move-target (send *robot* :rarm :end-coords)
	     :use-torso nil
	     :rotation-axis t
	     :debug-view t)
       (push (send *robot* :angle-vector) avs)

       (print "place")
       (send des-cds :translate #f(0 0 -100) :world)
       (print des-cds)
       (send *robot* :inverse-kinematics
	     des-cds
	     :move-target (send *robot* :rarm :end-coords)
	     :use-torso nil
	     :rotation-axis t
	     :debug-view t)
       (push (send *robot* :angle-vector) avs)
       (setq avs (reverse avs))
       (send self :publish-joint-trajectory avs (list 1000 3000 1000) :real? t)
       (unix::sleep 3)
       (send self :stop-grasp :arm :rarm)
       (unix::sleep 5)
       )

     (let (avs)
       ;;pose-place
       (print "post place")
       (send des-cds :translate #f(-100 0 0))
       (send *robot* :inverse-kinematics
	     des-cds
	     :move-target (send *robot* :rarm :end-coords)
	     :use-torso nil
	     :rotation-axis t
	     :debug-view t)
       (push (send *robot* :angle-vector) avs)
       (setq avs (reverse avs))
       (send self :publish-joint-trajectory avs (list 2000) :real? t)
       )
     (objects (list *pr2* start-cds des-cds))
     )
   )

  (:start-grasp
   (&key (arm :arms))
   (send self :send-grasp-msg "start-grasp" :arm arm)
   )

  (:stop-grasp
   (&key (arm :arms))
   (send self :send-grasp-msg "stop-grasp" :arm arm)
   )
  
  (:send-grasp-msg
   (pose-data &key (arm :arms))
   (let ((hand-msg (instance std_msgs::String :init)))
     (send hand-msg :data (format nil "~A_~A" pose-data arm))
     (ros::publish (format nil "~A/~A/hand_ri_move" *im-nodename* *robot-topic-name*)
		   hand-msg)
     )
   )

  (:make-centroid-object
   ()
   (setq *centroid-object* (make-cylinder 20 400))
   (send *centroid-object* :set-color #F(1 1 0)))

  (:init 
   ()
   (defvar *target-coords* (instance arrow-object :init))
   (send *target-coords* :translate #f(500 0 0)) ;; initial pose
   (defvar *origin-coords* (instance arrow-object :init)) ;;arrow for origin of object
   (send *origin-coords* :translate #f(500 0 0))
   (defvar *old-coords* (send *target-coords* :copy-worldcoords))
   (defvar *use-fullbody* t)
   (defvar *use-torso* nil)
   (defvar *translation-axis* t)
   (defvar *rotation-axis* t)
   (defvar *tmp-rotation-axis* t) ;;turn nil when center sphere was moved
   ;;baxter
   ;;(defvar *publish-ik* t)
   (defvar *publish-ik* nil)
   (defvar *origin-key* :rarm)

   (defvar *robot-name* (ros::get-param "~robot" "PR2"))
   (defvar *robot-topic-name* (ros::get-param "~robot_topic_name" "robot"))
   (setq *use-ik-server* (ros::get-param "~use_ik_server" t))
   (setq *frame-id* (ros::get-param "~frame_id" "map"))
   (setq *one-click-grasp* (ros::get-param "~one_click_grasp" nil))
   (setq *one-click-grasp-arm* (intern (string-upcase (ros::get-param "~one_click_grasp_arm" "rarm")) *keyword-package*))

   (setq *publish-ik* (ros::get-param "~start_ik" t))
   (defvar *ik-stop* (not *publish-ik*))

   (defvar *rhand-frame* nil)
   (defvar *lhand-frame* nil)
   
   (setq *ik-update-times* 0)
   (setq *target-update-times* 0)

   (defvar *start-loop* t)
   ;;init robot
   (cond
    ((equal (string-upcase *robot-name*) "PR2")
     (setq *robot-name* "PR2")
     (setq *PR2* (pr2))
     (setq *robot* *PR2*)
     (setq *have-leg* nil)
     )
    ((equal (string-upcase *robot-name*) "BAXTER")
     (require "package://baxtereus/baxter-interface.l")
     (setq *robot-name* "BAXTER")
     (setq *baxter* (baxter))
     (setq *robot* *baxter*)
     (setq *have-leg* nil)
     )
    ((equal (string-upcase *robot-name*) "ATLAS")
     (ros::load-ros-manifest "hrpsys_gazebo_atlas")
     (ros::roseus-add-msgs "hrpsys_gazebo_atlas")
     (setq *robot-name* "atlas")
     (require "package://hrpsys_gazebo_atlas/euslisp/atlas-model.l")
     (require "package://hrpsys_gazebo_atlas/euslisp/atlas-fullbody-ik.l")
     (require "package://hrpsys_gazebo_atlas/euslisp/atlas-joint-state-compresser-settings.l")
     (require "package://hrpsys_gazebo_atlas/euslisp/atlas-end-coords.l")
     (atlas-with-hand)
     (setq *robot* *atlas*)
     (setq *have-leg* t)
     )
    ((equal (string-upcase *robot-name*) "HRP2JSKNT")
     (setq *robot-name* "hrp2jsknt")
     (load "package://hrpsys_ros_bridge_tutorials/euslisp/hrp2jsknt-interface.l")
     (setq *robot* (instance hrp2jsknt-robot :init))
     (setq *have-leg* t)
     )
    ((equal (string-upcase *robot-name*) "HRP2JSKNTS")
     (setq *robot-name* "hrp2jsknts")
     (load "package://hrpsys_ros_bridge_tutorials/euslisp/hrp2jsknts-interface.l")
     (setq *robot* (instance hrp2jsknts-robot :init))
     (setq *have-leg* t)
     )
    ((equal (string-upcase *robot-name*) "HRP2W")
     (require "package://hrpsys_ros_bridge_tutorials/euslisp/hrp2w-interface.l")
     (hrp2w-init)
     (setq *robot* *hrp2w*)
     (defvar *robot-origin* "BODY")
     (defvar *robot-offset* (send (send *robot* :body_lk :copy-worldcoords) :transformation (make-coords)))
     (setq *have-leg* nil)
     )
    ((equal (string-upcase *robot-name*) "STARO")
     (load "package://jsk_hrpsys_ros_bridge/euslisp/staro-interface.l")
     (setq *robot* (instance staro-robot :init))
     (setq *have-leg* t)
     )
    ((equal (string-upcase *robot-name*) "SAMPLEROBOT")
     (load "package://hrpsys_ros_bridge_tutorials/euslisp/samplerobot-interface.l")
     (setq *robot* (instance samplerobot-robot :init))
     (setq *have-leg* t)
     )
    (t
     (ros::ros-error "undefined robot: ~A" *robot-name*)
     (ros::ros-error "use PR2")
     (setq *PR2* (pr2))
     (setq *robot* *PR2*)
     (setq *have-leg* nil)
     )
    )
   (defvar *robot-origin* (send (car (send *robot* :links)) :name))


   (defvar *im-nodename* "jsk_model_marker_interface")
   (defvar *gripper-im-nodename* "gripper_marker_for_interactive_marker_interface")
   (defvar *server-nodename*
     "/jsk_interactive_marker_manipulation")

   (defvar *interactive-pc-nodename* "/interactive_point_cloud")
   (defvar *bounding-box-nodename* "/bounding_box_marker")
   (defvar *nodename* "ik_controller")

   ;;initialize joint-index-list
   ;;it is used to convert joint-name -> index
   ;;(joint-index-init)
   
   (ros::roseus *nodename*)
   (setq *tfb* (instance ros::transform-broadcaster :init))
   (setq *tfl* (instance ros::transform-listener :init))
   (setq *fullbody-ik-client* (instance fullbody-ik-client :init))

   (ros::roseus-add-msgs "sensor_msgs")
   (ros::subscribe "/spacenav/joy"
		   sensor_msgs::Joy
		   #'send self :spacenav-subscriber
		   1)

   (ros::advertise (format nil "~A/status" *nodename*)
		   jsk_rviz_plugins::OverlayText)
   (ros::advertise (format nil "~A/ik_status" *nodename*)
		   jsk_rviz_plugins::OverlayText)


   (ros::advertise (format nil "~A/marker" *server-nodename*)
		   visualization_msgs::Marker)
   (ros::advertise (format nil "~A/set_pose" *server-nodename*)
		   geometry_msgs::PoseStamped)
   (ros::advertise
    (format nil "~A/origin_marker" *server-nodename*)
    visualization_msgs::Marker)
   (ros::subscribe
    (format nil "~A/pose" *server-nodename*)
    jsk_interactive_marker::MarkerPose #'send self :pose-callback 1)
   (ros::subscribe
    (format nil "~A/marker_menu" *server-nodename*)
    jsk_interactive_marker::MarkerMenu #'send self :marker-menu-callback 1)
   (ros::subscribe
    (format nil "~A/marker_menu" *im-nodename*)
    jsk_interactive_marker::MarkerMenu #'send self :robot-marker-menu-callback 1)
   (ros::subscribe
    (format nil
	    "/~A/joint_states_decompressed" *robot-topic-name*)
    sensor_msgs::JointState
    #'send self :joint-state-subscriber 1)

   (ros::subscribe
    "/multisense_sl/joint_states_decompressed"
    sensor_msgs::JointState
    #'send self :joint-state-subscriber 1)

   ;;Update Interactive Marker
   (ros::advertise
    (format nil "~A/~A/reset_joint_states" *im-nodename* *robot-topic-name*)
    sensor_msgs::JointState)
   ;; set Interactive Marker Root Pose
   (ros::advertise (format nil "~A/~A/set_pose" *im-nodename* *robot-topic-name*)
		   geometry_msgs::PoseStamped)

   ;; reset Interactive Marker Root Pose
   (ros::advertise (format nil "~A/~A/reset_root_pose" *im-nodename* *robot-topic-name*)
		   std_msgs::Empty)
   
   ;;update real-robot joint state
   (ros::subscribe
    (format nil "~A/~A/joint_states" *im-nodename* *robot-topic-name*)
    sensor_msgs::JointState #'send self :robot-marker-joint-state-subscriber)

   (ros::advertise
    (format nil "~A/~A/joint_states_ri_move" *im-nodename* *robot-topic-name*)
    sensor_msgs::JointState)

   (ros::advertise
    (format nil "~A/~A/joint_trajectory_ri_move" *im-nodename* *robot-topic-name*)
    trajectory_msgs::JointTrajectory)

   (ros::advertise
    (format nil "~A/~A/hand_ri_move" *im-nodename* *robot-topic-name*)
    std_msgs::String)

   (ros::advertise (format nil "~A/~A/base_move" *im-nodename* *robot-topic-name*)
		   geometry_msgs::PoseStamped)

   (ros::advertise (format nil "~A/l_gripper/set_pose" *gripper-im-nodename*)
		   geometry_msgs::PoseStamped)

   (ros::subscribe
    (format nil "~A/~A/base_pose" *im-nodename* *robot-topic-name*)
    geometry_msgs::PoseStamped #'send self :base-target-callback)

   (ros::subscribe
    (format nil "~A/grasp_pose" *server-nodename*)
    geometry_msgs::PoseStamped #'send self :grasp-pose-callback)

   (ros::subscribe
    (format nil "~A/marker_pose" *interactive-pc-nodename*)
    geometry_msgs::PoseStamped #'send self :move-object-callback)

   (ros::subscribe
    (format nil "~A/box_movement" *interactive-pc-nodename*)
    jsk_pcl_ros::BoundingBoxMovement #'send self :box-movement-callback)

   (ros::subscribe
    (format nil "~A/move_model" *im-nodename*)
    jsk_interactive_marker::MoveModel #'send self :move-model-callback)

   (if *one-click-grasp*
       (ros::subscribe
	(format nil "~A/grasp_pose" *interactive-pc-nodename*)
	geometry_msgs::PoseStamped #'send self :grasp-pose-callback)
     )
   (send self :valve-init)


   (setq *real-robot* (copy-object *robot*))
   (gl::transparent *real-robot* 0.3)
   (setq *arrow* (arrow))
   (send self :make-centroid-object)

   (send self :init-pose)
   (send self :set-origin-to-hand *origin-key*)

   (objects
    (list *robot* *real-robot* *origin-coords* *target-coords*))
   (send *irtviewer* :change-background #f(0.9 0.9 1.0))
   (send *irtviewer* :title "Interactive IK")

   (send-all (send *robot* :joint-list) :max-joint-velocity 0.3)

   (defvar *mouse-mode* nil)
   (defvar *success-state-collection* nil)
   (defvar *move-limb* :rarm)

   (defvar *prev-js*
     (instance sensor_msgs::jointstate
	       :init
	       :header
	       (instance std_msgs::Header :init
			 :stamp (ros::time 0.0)
			 :frame_id (format nil "/~A" *robot-origin*))
	       :position
	       (map float-vector
		    #'deg2rad
		    (send *robot* :angle-vector))
	       :name
	       (send-all (send *robot* :joint-list) :name)))

   (when *have-leg*
     (send *robot* :rleg :knee-p :min-angle 10)
     (send *robot* :lleg :knee-p :min-angle 10))

   (send *robot* :angle-vector
	 (copy-object (send *real-robot* :angle-vector)))
   (send self :fix-robot-coords)
   (send *irtviewer* :draw-objects)
   (send *irtviewer* :look-all)

   (ros::rate 100)
   
   (send self :set-marker-pose-robot (send *target-coords* :worldcoords))
   ;;update *real-robot* and joint marker pose
   (send self :realmodel2model)
   (send self :publish-joint-states :real? nil)
   (send self :publish-status)
   (if *start-loop* (send self :main-loop))
   )

  (:valve-init
   ()
   (load "package://tarukosu_drc_valve_task/euslisp/variable-valve-model.l")
   (setq *valve-ready* nil)
   (setq *valve-thick* 10)
   (setq *valve-radius* 200)
   (setq *robot-coords* (make-coords))
   (setq *valve-coords* (make-coords))
   (setq *valve-pre-angle* 0)
   (setq *valve-angle* 0)
   (setq *valve* (instance variable-valve :init :thick *valve-thick* :radius *valve-radius*))
   (setq *handle* (make-cascoords :coords (send *valve* :coords)))
   (send *handle* :move-to (car (send *valve* :handle)))
   (send *handle* :translate #f(50 0 0) :local)
   (send *handle* :translate #f(0 50 50) :local)
   (send (car (send *valve* :handle)) :assoc *handle*)

   (objects (list *robot* *valve*))
   ;;(send *irtviewer* :change-background #f(0.4 0.7 0.5))
   ;;(send *irtviewer* :draw-objects)
   (setq *initial-valve-angle* 0)
   ;;     (ros::subscribe "/urdf_control_marker/pose" geometry_msgs::PoseStamped #'robot-pose-cb)
   (ros::subscribe "/set_urdf_marker/object/base_pose" geometry_msgs::PoseStamped #'send self :object-pose-cb)
   ;;(ros::subscribe "/valve_model_pose" geometry_msgs::PoseStamped #'send self :valve-pose-cb)
   (ros::subscribe "/valve_model_thick" std_msgs::Float32 #'send self :valve-model-thick-cb)
   (ros::subscribe "/valve_model_radius" std_msgs::Float32 #'send self :valve-model-radius-cb)
   (ros::subscribe "/update_eus_model" std_msgs::bool #'send self :update-eus-model-cb)
   (ros::subscribe "/set_urdf_marker/object/joint_states" sensor_msgs::JointState #'send self :update-eus-model-cb)
   (ros::subscribe "/set_urdf_marker/move_object" jsk_interactive_marker::MoveObject #'send self :move-valve-cb)
   
   )
  
  (:update-eus-model-cb
   (msg)
   (setq *valve-angle* (elt (send msg :position) 0))
   )

  (:object-pose-cb
   (msg)
   (objects (list *valve* *robot*))
   (setq *valve-coords* (ros::tf-pose-stamped->coords msg))
   (send *valve* :move-to *valve-coords* :world)
   )

  (:update-valve-model
   ()
   (setq *valve* (instance variable-valve :init :thick *valve-thick* :radius *valve-radius*))
   (setq *handle* (make-cascoords :coords (send *valve* :coords)))
   (send *handle* :move-to (car (send *valve* :handle)))
   (send *handle* :translate #f(50 0 0) :local)
   (send *handle* :translate #f(0 50 50) :local)
   (send (car (send *valve* :handle)) :assoc *handle*)
   (send *valve* :move-to *valve-coords* :world)
   )

  (:valve-model-thick-cb
   (msg)
   (setq *valve-thick* (send msg :data))
   (send self :update-valve-model)
   )

  (:valve-model-radius-cb
   (msg)
   (setq *valve-radius* (send msg :data))
   (send self :update-valve-model)
   )

  (:move-valve-cb
   (msg)
   (objects (list *valve* *robot* *handle*))
   (setq *ik-stop* t)
   (setq *publish-ik* nil)

   ;;ready to rotate
   (unless *valve-ready*
     (send *valve* :angle-vector (float-vector (rad2deg *valve-pre-angle*)))
     (setq pre-pose (send *handle* :copy-worldcoords))
     (send pre-pose :locate #f(-250 0 0) :local)
     (objects (list *robot* *valve* pre-pose))
     (send *robot* :rarm :inverse-kinematics pre-pose
	   :rotation-axis :x)
     (send *irtviewer* :draw-objects)
     (send self :publish-joint-states :real? nil)
     (send self :publish-joint-states :real? t)
     (unix::sleep 2)

     (send *robot* :rarm :inverse-kinematics *handle*
	   :rotation-axis :x)
     (send self :publish-joint-states :real? nil)
     (send self :publish-joint-states :real? t)
     (unix::sleep 2)

     (setq *valve-ready* t)
     )
   (dotimes (i 11)
     (send *valve* :angle-vector (float-vector (rad2deg (+ *valve-pre-angle* 
							   (* (/ (- *valve-angle* *valve-pre-angle*) 10.0) i)))))
     (send *robot* :rarm :inverse-kinematics *handle*
	   :rotation-axis t)
     (objects (list *valve* *robot* *handle*))
     )

   (send self :publish-joint-states :real? nil)
   (send self :publish-joint-states :real? t)
   (unix::sleep 1)
   (objects (list *valve* *robot* *handle*))
     
   (print *valve-angle*)
   (print *valve-pre-angle*)
   (setq *valve-pre-angle* *valve-angle*)
   )

  (:demo-mouse-controller
   nil
   (ros::rate 10)
   (do-until-key
    (if (not (ros::ok)) (return-from nil nil))
    ;;    (x::window-main-one)
    (ros::spin-once)
    (ros::sleep)))

  (:main-loop
   nil
   (let (ret move rot buf tmp str)
     (do-until-key
      ;;(bench
       (do-until-key
	(x::window-main-one)
	(ros::spin-once)
	(if (not *mouse-mode*) (return-from nil nil))
	)
       (cond
	(*ik-stop*
	 (unix:usleep (round (* 1000 100))))
	(t
	 (let ((move-arms '(t t))
	       (use-torso (or *use-torso* *use-fullbody*))
	       rotation-axis
	       target-coords
	       move-target)

	   (setq move-arms
		 (case *move-limb*
		   (:rarm '(nil t))
		   (:larm '(t nil))
		   (:arms '(t t))))

	   (if *have-leg*
	       (progn
		 (setq move-arms (append move-arms '(nil nil)))
		 (setq target-limbs '(:larm :rarm :lleg :rleg))
		 )
	     (setq target-limbs '(:larm :rarm)))
	   (setq rotation-axis (mapcar #'(lambda (move-arm) (if move-arm (if *tmp-rotation-axis* *rotation-axis* nil) t)) move-arms))

	   (cond
	    ((or (equal (string-upcase *robot-name*) "HRP2JSKNT") (equal (string-upcase *robot-name*) "HRP2JSKNTS"))

	     (mapcar
	      #'(lambda (k)
		  (send *real-robot*
			:put (read-from-string (format nil "~A-ankle-end-coords" k))
			(make-cascoords
			 :name (read-from-string (format nil "~A-ankle-end-coords" k))
			 :parent (send (send *real-robot* k :end-coords :parent) :parent)
			 :coords (send (send *real-robot* k :end-coords) :copy-worldcoords))))
	      '(:lleg :rleg))

	     (setq move-target (list (send *real-robot* :larm :end-coords)
				     (send *real-robot* :rarm :end-coords)
				     (send *real-robot* :get :lleg-ankle-end-coords)
				     (send *real-robot* :get :rleg-ankle-end-coords)))

	     ;;ik target
	     (setq target-coords
		   (mapcar #'(lambda (arm move-arm)
			       (if move-arm
				   (let* ((origin->hand (send (send *origin-coords* :transformation arm) :copy-worldcoords))
					  (hand (send origin->hand :transform *target-coords* :world)))
				     hand)
				 (send arm :copy-worldcoords)))
			   move-target move-arms))
	     )
	    (t
	     ;;ik target
	     (setq target-coords
		   (mapcar #'(lambda (arm move-arm)
			       (if move-arm
				   (let* ((origin->hand (send (send *origin-coords* :transformation (send *real-robot* arm :end-coords)) :copy-worldcoords))
					  (hand (send origin->hand :transform *target-coords* :world)))
				     hand)
				 (send *real-robot* arm :end-coords :copy-worldcoords)))
			   target-limbs move-arms))))

	   (if *use-ik-server*
	       (cond
		((equal (string-upcase *robot-name*) "PR2")
		 (setq ik-server-res
		       (send *fullbody-ik-client* :ik-server-call
			     :robot *robot*
			     :target-limbs target-limbs
			     :target-coords target-coords
			     :stop 50
			     :rotation-axis rotation-axis
			     ;;for pr2?
			     :use-torso use-torso
			     :group-name ":inverse-kinematics"
			     :centroid-thre nil
			     :target-centroid-pos nil
			     :cog-gain 0
			     )
		       )
		 )
		((or (equal (string-upcase *robot-name*) "HRP2JSKNT") (equal (string-upcase *robot-name*) "HRP2JSKNTS"))
		 (cond
		  (*use-fullbody*
		   (setq ik-server-res
			 (send *fullbody-ik-client* :ik-server-call
			       :robot *robot*
			       :target-coords target-coords
			       :stop 50
			       :rotation-axis rotation-axis
			       :move-target move-target
			       )))
		  (*use-torso*
		   (send *robot* :fix-leg-to-coords (make-coords) :both)
		   (setq ik-server-res
			 (send *fullbody-ik-client* :ik-server-call
			       :robot *robot*
			       :target-coords (subseq target-coords 0 2)
			       :stop 50
			       :rotation-axis (subseq rotation-axis 0 2)
			       :move-target (subseq move-target 0 2)
			       ))
		   )
		  (t
		   (let ((mt (append (subseq move-target 0 2) (list (send *real-robot* :torso :end-coords))))
			 (tc (append (subseq target-coords 0 2) (list (send *real-robot* :torso :end-coords :copy-worldcoords))))
			 (rt (append (subseq rotation-axis 0 2) '(t))))
		     (setq ik-server-res
			   (send *fullbody-ik-client* :ik-server-call
				 :robot *robot*
				 :target-coords tc
				 :stop 50
				 :rotation-axis rt
				 :move-target mt
				 )))))
		 )
		(t
		 (format t "[ik-server]")
		 (bench
		  (setq ik-server-res
			(send *fullbody-ik-client* :ik-server-call
			      :robot *robot*
			      :target-limbs target-limbs
			      :target-coords target-coords
			      :stop 50
			      :rotation-axis rotation-axis
			      ;;:use-torso use-torso
			      ;;:group-name ":inverse-kinematics"
			      ;;:centroid-thre nil
			      ;;:target-centroid-pos nil
			      ;;:cog-gain 0
			      )))))
	     (setq ik-suc
		   (send *robot* :inverse-kinematics
			 target-coords
			 :move-arm :arms
			 :use-torso use-torso
			 :rotation-axis rotation-axis
			 :stop 100
			 :debug-view nil))
	     )
	   (cond
	    ((if *use-ik-server* (= (send ik-server-res :error_code :val) moveit_msgs::MoveItErrorCodes::*SUCCESS*) (vectorp ik-suc))
	     (setq revert-if-fail t)
	     (send self :publish-ik-status (format nil " IK SUCCESS"))
	     (print (send *robot* :angle-vector))
	     (if *publish-ik*
		 (send self :publish-joint-states :real? nil)))
	    (t ;(evenp (random 2))
	     (setq revert-if-fail t)
	     (send self :publish-ik-status (format nil " IK FAIL") :status :ERROR)
	     ))
	   (setq *ik-update-times* (1+ *ik-update-times*))
	   (send self :publish-status)
	   )))
       )))
  )
